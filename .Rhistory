for (i in 1:332) {
dati <- read.csv(files[i])
good <- complete.cases(dati) ##creates logicals of complete cases
sumi <- sum(good)
if (sumi > threshold) {  ##if number of complete cases exceeds threshold, find corr
datcc <- dati[good,]  ##creates dataframe of records with complete cases
svec <- datcc[2]  ##sulfate vector
nvec <- datcc[3]  ##nitrate vector
corrvec <- cor(svec, nvec)
corrdat <- c(corrdat, corrvec)
}
corrdat
}
}
cr <- corr("specdata", 150)
head(cr)
files <- list.files("specdata", full.name = TRUE)
corrdat <- c()
corrvec <- c()
dati <- read.csv(files[1])
good <- complete.cases(dati)
sumi <- sum(good)
sumi
datcc <- dati[good,]
svec <- datcc[2]  ##sulfate vector
nvec <- datcc[3]  ##nitrate vector
corrvec <- cor(svec, nvec)
corrvec
corrdat <- c(corrdat, corrvec)
corrdat
dati <- read.csv(files[2])
good <- complete.cases(dati) ##creates logicals of complete cases
sumi <- sum(good)
datcc <- dati[good,]  ##creates dataframe of records with complete cases
svec <- datcc[2]  ##sulfate vector
nvec <- datcc[3]  ##nitrate vector
corrvec <- cor(svec, nvec)
corrvec
corrdat <- c(corrdat, corrvec)
corrdat
dati <- read.csv(files[i])
good <- complete.cases(dati) ##creates logicals of complete cases
sumi <- sum(good)
dati <- read.csv(files[3])
good <- complete.cases(dati) ##creates logicals of complete cases
sumi <- sum(good)
sumi
datcc <- dati[good,]  ##creates dataframe of records with complete cases
svec <- datcc[2]  ##sulfate vector
nvec <- datcc[3]  ##nitrate vector
corrvec <- cor(svec, nvec)
corrvec
corrdat <- c(corrdat, corrvec)
corrdat
?print
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.name = TRUE)
corrdat <- c()
corrvec <- c()
for (i in 1:332) {
dati <- read.csv(files[i])
good <- complete.cases(dati) ##creates logicals of complete cases
sumi <- sum(good)
if (sumi > threshold) {  ##if number of complete cases exceeds threshold, find corr
datcc <- dati[good,]  ##creates dataframe of records with complete cases
svec <- datcc[2]  ##sulfate vector
nvec <- datcc[3]  ##nitrate vector
corrvec <- cor(svec, nvec)
corrdat <- c(corrdat, corrvec)
}
print(corrdat)
}
}
cr <- corr("specdata", 150)
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.name = TRUE)
corrdat <- c()
corrvec <- c()
for (i in 1:332) {
dati <- read.csv(files[i])
good <- complete.cases(dati) ##creates logicals of complete cases
sumi <- sum(good)
if (sumi > threshold) {  ##if number of complete cases exceeds threshold, find corr
datcc <- dati[good,]  ##creates dataframe of records with complete cases
svec <- datcc[2]  ##sulfate vector
nvec <- datcc[3]  ##nitrate vector
corrvec <- cor(svec, nvec)
corrdat <- c(corrdat, corrvec)
}
}
}
cr <- corr("specdata", 150)
head(cr)
source("corr.R")
cr <- corr("specdata",100)
source("corr.R")
cr <- corr("specdata",100)
head(cr)
source("corr.R")
cr <- corr("specdata", 100)
head(Cr)
head(cr)
for (i in 1:332) {
corr <- function(directory, threshold = 0) {
corr <- function(directory, threshold = 0) {
source('~/.active-rstudio-document')
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.name = TRUE)
corrdat <- c()
corrvec <- c()
for (i in 1:332) {
dati <- read.csv(files[i])
good <- complete.cases(dati) ##creates logicals of complete cases
sumi <- sum(good)
if (sumi > threshold) {  ##if number of complete cases exceeds threshold, find corr
datcc <- dati[good,]  ##creates dataframe of records with complete cases
svec <- datcc[2]  ##sulfate vector
nvec <- datcc[3]  ##nitrate vector
corrvec <- cor(svec, nvec)
corrdat <- c(corrdat, corrvec)
}
corrdat
}
}
##finds correlation between pollutants for each monitor, provided monitor is above threshold of complete cases
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.name = TRUE)
corrdat <- c()
corrvec <- c()
for (i in (1:332)) {
dati <- read.csv(files[i])
good <- complete.cases(dati) ##creates logicals of complete cases
sumi <- sum(good)
if (sumi > threshold) {  ##if number of complete cases exceeds threshold, find corr
datcc <- dati[good,]  ##creates dataframe of records with complete cases
svec <- datcc[2]  ##sulfate vector
nvec <- datcc[3]  ##nitrate vector
corrvec <- cor(svec, nvec)
corrdat <- c(corrdat, corrvec)
}
corrdat
}
}
cr <- corr("specdata", 150)
head(cr)
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.name = TRUE)
corrdat <- c()
corrvec <- c()
for (i in 1:332) {
dati <- read.csv(files[i])
good <- complete.cases(dati) ##creates logicals of complete cases
sumi <- sum(good)
datcc <- dati[good,]  ##creates dataframe of records with complete cases
if (sumi > threshold) {  ##if number of complete cases exceeds threshold, find corr
svec <- datcc[2]  ##sulfate vector
nvec <- datcc[3]  ##nitrate vector
corrvec <- cor(svec, nvec)
corrdat <- c(corrdat, corrvec)
}
corrdat
}
}
cr <- corr("specdata", 150)
head(cr)
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.name = TRUE)
corrdat <- c()
corrvec <- c()
for (i in 1:332) {
dati <- read.csv(files[i])
good <- complete.cases(dati) ##creates logicals of complete cases
sumi <- sum(good)
if (sumi > threshold) {  ##if number of complete cases exceeds threshold, find corr
datcc <- dati[good,]  ##creates dataframe of records with complete cases
svec <- datcc[2]  ##sulfate vector
nvec <- datcc[3]  ##nitrate vector
corrvec <- cor(svec, nvec)
corrdat <- c(corrdat, corrvec)
}
print(corrdat)
}
}
cr <- corr("specdata", 150)
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.name = TRUE)
corrdat <- c()
corrvec <- c()
for (i in 1:332) {
dati <- read.csv(files[i])
good <- complete.cases(dati) ##creates logicals of complete cases
sumi <- sum(good)
if (sumi > threshold) {  ##if number of complete cases exceeds threshold, find corr
datcc <- dati[good,]  ##creates dataframe of records with complete cases
svec <- datcc[2]  ##sulfate vector
nvec <- datcc[3]  ##nitrate vector
corrvec <- cor(svec, nvec)
corrdat <- c(corrdat, corrvec)
}
}
corrdat
}
cr <- corr("specdata", 150)
head(cr)
source("corr.R")
cr <- corr("specdata", 150)
head(cr)
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript1.R")
submit()
9
submit()
submit()
library(datasets)
data(mtcars)
head(mtcars)
tapply(mtcars$hp, mtcars$cyl, mean)
hpcyl <- tapply(mtcars$hp, mtcars$cyl, mean)
diffe <- max(hpcyl) - min(hpcyl)
diffe
sapply(split(mtcars$mpg, mtcars$cyl),mean)
sapply(split(mtcars$hp, mtcars$cyl),mean)
hpcyl1 <- sapply(split(mtcars$hp, mtcars$cyl),mean)
max(hpcyl1)-min(hpcyl1)
?`<<-`
file.rename("W3A3Ex.R", "makeVector.R")
source("makeVector.R")
ls()
x <- makeVector(c(1,2,3))
x$get()
x$set
x$setmean
x$set()
x$setmean()
x$getmean()
ls()
cachemean(x)
source("cachemean.R")
cachemean(x)
x$get()
source("cachemean.R")
cachemean(x)
file.rename("cachemean.R", "cachemean2.R")
source("cachemean.R")
cachemean(x)
cachemean(x)
x$set(c(4,5,6))
x$get()
cachemean(x)
cachemean(x)
?NULL
?`<<-`
x$get()
x$setmean(m)
x$setmean()
ls()
?solve
x
x()
makeCacheMatrix <- function(x = numeric()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function()
x
setinv <- function ()
m <<- solve
getinv <- function()
m
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
makeCacheMatrix([1,1;1,1])
makeCacheMatrix(matrix(1:4,2,2))
makeCacheMatrix <- function(x = numeric()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function()
x
setinv <- function (solve)
m <<- solve
getinv <- function()
m
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
makeCacheMatrix(matrix(1:4,2,2))
makeVector <- function(x = numeric()) {  ##make a function
m <- NULL  ##Create a null value
set <- function(y) {  ##1st function: sets x,m as variables searchable in other environments
x <<- y
m <<- NULL
}
get <- function()  ##2nd function: returns the value of x
x
setmean <- function(mean)  ##3rd: sets m to mean, searchable in other environments
m <<- mean
getmean <- function()  ##4th: returns the mean value of x
m
list(set = set, get = get, setmean = setmean, getmean = getmean)  ##Lists makeVector functions
}
makeVector(1:4)
makeVector(1:3)
x$get()
ls()
rm(list=ls())
ls()
makeVector(1:3)
source(makeVector.R)
source("makeVector.R")
makeVector(1:3)
x$get
x$get()
x <- makeVector(1:3)
x$get()
source("W3Assign.R")
file.rename("W3Assign3.R", "W3Assign.R")
source("W3Assign.R")
y <- makeCacheMatrix(matrix(1:4,2,2))
y$get()
y$getinv()
source("W3Assign.R")
rm(list=ls())
ls()
y <- makeCacheMatrix(matrix(1:4,2,2))
source("W3Assign.R")
y <- makeCacheMatrix(matrix(1:4,2,2))
y$get()
y$getinv()
source("W3Assign.R")
y$getinv()
rm(list=ls())
source("W3Assign.R")
y <- makeCacheMatrix(matrix(1:4,2,2))
y$get()
y$getinv()
source(makeVector.R)
source("makeVector.R")
makeVector(1:4)
tt <- makeVector(1:4)
tt$get()
tt$getmean()
rm(list=ls())
soure("makeVectorEx.R")
source("makeVectorEx.R")
x <- makeVector(1:$)
x <- makeVector(1:4)
x
x$get()
x$getmean()
rm(list=ls())
ls()
source("W3Assign.R")
x <- makeCacheMatrix(matrix(1:4,2,2))
x$get()
x$getinv()
cachemean(x)
cacheSolve(x)
?traceback
traceback90
traceback()
cacheSolve(x)
traceback()
source("makeVector.R")
source("cachemean.R")
makeVector(1:4)
x<-makeVector(1:4)
x$get()
x$getmean()
cachmean(x)
cachemean(x)
source("W3Assign.R")
rm(list=ls())
source("W3Assign.R")
x <- makeCacheMatrix(matrix(1:4,2,2))
x$get()
x$getinv()
cacheSolve(x)
cacheSolve(x)
ls()
rm(list=ls())
source("makeCacheMatrix.R")
source("cacheSolve.R")
my_matrix = matrix(c(1,1,3,1), nrow=2, ncol=2)
x <- makeCacheMatrix(my_matrix)
x$get()
cacheSolve(x)
cacheSolve(x)
my_matrix = matrix( c(1, 1, 2, 4, 1, 3, 2, 2, 1), nrow=3, ncol=3)
x$set(my_matrix)
x$get()
cacheSolve(x)
cacheSolve(x)
rm(list=ls())
# Test your code
source("cachematrix.R")
#
# generate matrix, and the inverse of the matrix.
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
#
# now solve the matrix via the cache-method
#
special.matrix   <- makeCacheMatrix(mymatrix)
#
# this should take long, since it's the first go
special.solved.1 <- cacheSolve(special.matrix)
#
# this should be lightning fast
special.solved.2 <- cacheSolve(special.matrix)
#
# check if all solved matrices are identical
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
#
# should return TRUE
source(cacheSolve.R)
source("cacheSolve.R")
# Test your code
source("makeCacheMatrix.R")
#
# generate matrix, and the inverse of the matrix.
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
#
# now solve the matrix via the cache-method
#
special.matrix   <- makeCacheMatrix(mymatrix)
#
# this should take long, since it's the first go
special.solved.1 <- cacheSolve(special.matrix)
#
# this should be lightning fast
special.solved.2 <- cacheSolve(special.matrix)
#
# check if all solved matrices are identical
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
#
# should return TRUE
file.rename("makeCacheMatrix.R","cachematrix.R")
file.remove("cacheSolve.R")
# Test your code
source("cachematrix.R")
#
# generate matrix, and the inverse of the matrix.
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
#
# now solve the matrix via the cache-method
#
special.matrix   <- makeCacheMatrix(mymatrix)
#
# this should take long, since it's the first go
special.solved.1 <- cacheSolve(special.matrix)
#
# this should be lightning fast
special.solved.2 <- cacheSolve(special.matrix)
#
# check if all solved matrices are identical
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
#
# should return TRUE
rm(list=ls())
# Test your code
source("cachematrix.R")
#
# generate matrix, and the inverse of the matrix.
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
#
# now solve the matrix via the cache-method
#
special.matrix   <- makeCacheMatrix(mymatrix)
#
# this should take long, since it's the first go
special.solved.1 <- cacheSolve(special.matrix)
#
# this should be lightning fast
special.solved.2 <- cacheSolve(special.matrix)
#
# check if all solved matrices are identical
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
#
# should return TRUE
rm(list=ls())
# Test your code
source("cachematrix.R")
#
# generate matrix, and the inverse of the matrix.
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
#
# now solve the matrix via the cache-method
#
special.matrix   <- makeCacheMatrix(mymatrix)
#
# this should take long, since it's the first go
special.solved.1 <- cacheSolve(special.matrix)
#
# this should be lightning fast
special.solved.2 <- cacheSolve(special.matrix)
#
# check if all solved matrices are identical
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
#
# should return TRUE
